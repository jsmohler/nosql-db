
	Both PostgreSQL and MongoDB offer specific advantages and disadvantages for implementing the Bob's Pizza database. This project demonstrates the different value that different databases may bring to a project and how programmers should be careful to consider these factors before choosing a database. 

	The benefits provided by MongoDB were numerous. Perhaps the most evident advantage was the use of javascript as the primary language. Because javascript is so commonly used, it makes it much simpler to integrate functions, like taking orders, into the database itself. A secondary advantage is the use of subdocuments. While the project description did not explicitly call for subdocuments, using them for the names and addresses in the Users collection, made the database conceptually much easier to understand. Finally, MongoDB was very efficient with indexing. Not only does Mongo make it possible to index on any attribute, but the indexing process itself was very fast and substantially imporved query performance. 


	Postgre demonstrated many advantages and performed incredibly well. From a design perspective, it was super easy to design the database structure and then to maintain schemas since Postgre enforces that for you.  Additionally, the ease with which the user can query any field in any table with quite straight-forward syntax was also a major plus.  Indexing in Postgre is another significant benefit as demonstrated by the index on the orders table which reduced querying cost by over half!  In regards to inserting data, I was super impressed by the ease with which I could do mass data imports.  Not only was it simple (just execute the \copy command), but Postgre ensured the integrity of my data so well by rolling back / failing inaccurate data inserts.  Finally, the ability to join tables proved very helpful.  In fact, this was one of the fundamental requirements for the takeOrder function to work successfully.


	In addition to the advantages of using MongoDB, there are also several disadvantages that must be considered. For example, it is generally considered positive that MongoDB is schemaless, but for the purposes of this assignment, collection organization was far more rigid than traditional Mongo databases. This nullified the value of a schemaless database like Mongo and necessitated extra work in adding schema validation or have more contolled insertions and updates.

	Secondarily, while having referenced collections in MongoDB made it easier to relate two separate collections to one another, the lack of joins in Mongo meant we had to complete a significant number of queries. For example, when comparing the amount of ingredients in inventory to the amount required in a recipe for an order, a find query had to be repeatedly called on the inventory collection. This is less flexible than would be possiblle with a join because a join could immediately build a table that associated the values in the two different databases. 

	Finally, the lack of transactions in Mongo harmed the performance of updating the collections by requiring that you confirm a 'transaction' could be completed before the 'transaction' begins. In the createOrder function this meant iterating through every ingredient to confirm its amount and then iterating through each ingredient again to update them once it was confirmed there was enough. Comparatively, with transactions updates could be made along the way and rolled back if any part of the transaction fails. 

	The primary disadvantage experienced using Postgre was the difficulty of implementing a server-side function.  To be fair, a percentage of the floundering was due to lack of knowledge of PL/SQL implementation and syntax, however the lack of a typical debugger did not make this much easier.  
	
	While Mongo has the ability to nest subdocuments, Postgre does not and this presented a slight challenge during the design phase.  Instead of being able to store recipes and their required ingredients together, Postgre required a table that mapped ingredients to recipes (or this is one possible implementation).  This did complicate querying a bit, but in the end Postgre, as with many relational databases, has such extensive querying capabilities that this was not the biggest drawback.  

	The document-based organization and use of nested collections in MongoDB significantly helped with relating different collections to each other. The ability to use an array of objects was particularly helpful with the recipe collection, because it simplifies the process of associating multiple ingredients with their own quantity needs to a specific recipe. This then reduced the amount of information we had to handle because a single document could contain the information for the entire array of objects, rather than needing different tuples for every ingredient connected to a specific recipe. 	

	Postgre definitely shined in it's querying capabilities as well as its support of joining tables.  Since Postgre supports SQL, it was incredibly simple to query any combination of fields I could imagine -- whereas this is a bit more difficult in Mongo using JavaScript.  Furthermore, the ability to join tables proved to be indispensable in the takeOrders function.  As a result, I could iterate over relevant fields from a query to two tables as if it was a single record -- an incredibly convenient feature.  





